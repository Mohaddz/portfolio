<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Portfolio</title>
    <link>http://localhost:1313/portfolio/tags/java/</link>
    <description>Recent content in Java on Portfolio</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 21 May 2023 10:00:00 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/portfolio/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Building a Lexical Analyzer and SLR Parser in Java</title>
      <link>http://localhost:1313/portfolio/projects/compiler/</link>
      <pubDate>Sun, 21 May 2023 10:00:00 +0300</pubDate>
      <guid>http://localhost:1313/portfolio/projects/compiler/</guid>
      <description>Introduction In the realm of compiler design, two crucial components stand out: the Lexical Analyzer and the Parser. This project dives deep into implementing both, using Java as our weapon of choice. Let&amp;rsquo;s embark on this journey of transforming raw code into meaningful structures!&#xA;Part 1: The Lexical Analyzer What is a Lexical Analyzer? A lexical analyzer, often called a scanner or tokenizer, is the first phase of a compiler.</description>
    </item>
    <item>
      <title>Server-Client Character Occurrence Counter</title>
      <link>http://localhost:1313/portfolio/projects/hangman/</link>
      <pubDate>Mon, 13 Feb 2023 11:00:00 +0300</pubDate>
      <guid>http://localhost:1313/portfolio/projects/hangman/</guid>
      <description>Introduction This project implements a server-client program in Java that counts the occurrences of a specific character in a given string. The client sends a character and a string to the server, which then processes the request and returns the number of occurrences. This program utilizes TCP as the transport protocol, ensuring reliable and secure communication between the server and client.&#xA;Project Structure The project consists of two main components:</description>
    </item>
    <item>
      <title>Dynamic vs Normal Round Robin Scheduling Comparison</title>
      <link>http://localhost:1313/portfolio/projects/drr/</link>
      <pubDate>Tue, 15 Nov 2022 10:00:00 +0300</pubDate>
      <guid>http://localhost:1313/portfolio/projects/drr/</guid>
      <description>Github Repo 1. Introduction CPU scheduling is a crucial aspect of operating systems, allowing efficient utilization of CPU and I/O resources. This project implements and compares two variations of the Round Robin (RR) algorithm: Normal Round Robin and Dynamic Round Robin. The Round Robin algorithm is designed for time-sharing systems, allowing processes to use the CPU for a fixed time quantum before switching to the next process.&#xA;1.1 Understanding CPU Scheduling Before diving into the specifics of Round Robin algorithms, it&amp;rsquo;s essential to understand what CPU scheduling is:</description>
    </item>
  </channel>
</rss>
